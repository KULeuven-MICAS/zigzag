import logging
from typing import Any

from zigzag.cost_model.cost_model import CostModelEvaluation, CumulativeCME
from zigzag.stages.Stage import Stage, StageCallable

logger = logging.getLogger(__name__)


class MinimalEnergyStage(Stage):
    """! Class that keeps yields only the cost model evaluation that has minimal energy of all cost model evaluations
    generated by it's substages created by list_of_callables
    """

    def __init__(
        self,
        list_of_callables: list[StageCallable],
        *,
        reduce_minimal_keep_others: bool = False,
        **kwargs: Any,
    ):
        """
        Initialize the compare stage.
        """
        super().__init__(list_of_callables, **kwargs)
        # Visualization stuff
        self.energies: list[float] = []
        self.keep_others = reduce_minimal_keep_others

    def run(self):
        """! Run the compare stage by comparing a new cost model output with the current best found result."""
        sub_list_of_callables = self.list_of_callables[1:]
        substage: Stage = self.list_of_callables[0](sub_list_of_callables, **self.kwargs)

        other_cmes: list[tuple[CostModelEvaluation, Any]] = []
        best_cme: CostModelEvaluation | None = None
        for cme, extra_info in substage.run():
            assert isinstance(cme, CostModelEvaluation)
            self.energies.append(cme.energy_total)
            if (
                best_cme is None
                or cme.energy_total < best_cme.energy_total
                or (cme.energy_total == best_cme.energy_total and cme.latency_total2 < best_cme.latency_total2)
            ):
                best_cme = cme
            if self.keep_others:
                other_cmes.append((cme, extra_info))

        assert best_cme is not None
        yield best_cme, other_cmes


class MinimalLatencyStage(Stage):
    """! Class that keeps yields only the cost model evaluation that has minimal latency of all cost model evaluations
    generated by it's substages created by list_of_callables
    """

    def __init__(
        self,
        list_of_callables: list[StageCallable],
        *,
        reduce_minimal_keep_others: bool = False,
        **kwargs: Any,
    ):
        """
        Initialize the compare stage.
        """
        super().__init__(list_of_callables, **kwargs)
        self.keep_others = reduce_minimal_keep_others

    def run(self):
        """! Run the compare stage by comparing a new cost model output with the current best found result."""
        sub_list_of_callables = self.list_of_callables[1:]
        substage: Stage = self.list_of_callables[0](sub_list_of_callables, **self.kwargs)

        other_cmes: list[tuple[CostModelEvaluation, Any]] = []
        best_cme: CostModelEvaluation | None = None
        for cme, extra_info in substage.run():
            assert isinstance(cme, CostModelEvaluation)
            if (
                best_cme is None
                or cme.latency_total2 < best_cme.latency_total2
                or (cme.latency_total2 == best_cme.latency_total2 and cme.energy_total < best_cme.energy_total)
            ):
                best_cme = cme
            if self.keep_others:
                other_cmes.append((cme, extra_info))

        assert best_cme is not None
        yield best_cme, other_cmes


class MinimalEDPStage(Stage):
    """! Class that keeps yields only the cost model evaluation that has minimal EDP of all cost model evaluations
    generated by it's substages created by list_of_callables
    """

    def __init__(
        self,
        list_of_callables: list[StageCallable],
        *,
        reduce_minimal_keep_others: bool = False,
        **kwargs: Any,
    ) -> None:
        """
        Initialize the compare stage.
        """
        super().__init__(list_of_callables, **kwargs)
        self.keep_others = reduce_minimal_keep_others

    def run(self):
        """! Run the compare stage by comparing a new cost model output with the current best found result."""
        sub_list_of_callables = self.list_of_callables[1:]
        substage: Stage = self.list_of_callables[0](sub_list_of_callables, **self.kwargs)

        other_cmes: list[tuple[CostModelEvaluation, Any]] = []
        best_cme: CostModelEvaluation | None = None
        for cme, extra_info in substage.run():
            assert isinstance(cme, CostModelEvaluation)
            if (
                best_cme is None
                or cme.latency_total2 * cme.energy_total < best_cme.latency_total2 * best_cme.energy_total
            ):
                best_cme = cme
            if self.keep_others:
                other_cmes.append((cme, extra_info))

        assert best_cme is not None
        yield best_cme, other_cmes


class SumStage(Stage):
    """! Class that keeps yields only the sum of all cost model evaluations generated by its substages created by
    list_of_callables.
    """

    def run(self):
        substage: Stage = self.list_of_callables[0](self.list_of_callables[1:], **self.kwargs)

        all_cmes: list[tuple[CostModelEvaluation, Any]] = []
        total_cme = CumulativeCME()
        for cme, extra_info in substage.run():
            assert isinstance(cme, CostModelEvaluation)
            total_cme += cme
            all_cmes.append((cme, extra_info))
        yield total_cme, all_cmes
